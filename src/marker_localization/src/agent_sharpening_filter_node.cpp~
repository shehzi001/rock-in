#include <ros/ros.h>
#include <dynamic_reconfigure/server.h>
#include <sharpening_filter/SharpeningFilterConfig.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <cv.h>

//parameters for gaussianblur
int Ksize = 3;
double sigmaX = 0;
double sigmaY = 0;

//parameters for addweighted
double alpha = 1.5;
double beta = -1.0;
double gammaa = 0.0;
// defining variables for input and output topics
std::string input_topic;
std::string output_topic;
// declaring subscriber and publisher
ros::Subscriber image_sub;
ros::Publisher image_pub;

void dynamicReconfigureCallback(sharpening_filter::SharpeningFilterConfig &config, uint32_t level);
void imageCallBack(const sensor_msgs::ImageConstPtr& msg);
void toPublish(cv::Mat input);
cv::Mat applySharpening(cv::Mat inputImage);
//applies sharpening filter and returns the image
cv::Mat applySharpening(cv::Mat inputImage){

	cv::Mat temp = inputImage.clone();
    cv::GaussianBlur(inputImage, temp, cv::Size(Ksize, Ksize), sigmaX, sigmaY);
    cv::addWeighted(inputImage, alpha, temp, beta, gammaa, temp);
    inputImage = temp;
	return inputImage;

}

void imageCallBack(const sensor_msgs::ImageConstPtr& msg){

	cv::Mat myImage;
	cv_bridge::CvImagePtr cvPtr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
	myImage = cvPtr->image;
	myImage = applySharpening(myImage);
	toPublish(myImage);
	return;
}

void toPublish(cv::Mat input) {

	cv_bridge::CvImage out_msg;
	out_msg.encoding = sensor_msgs::image_encodings::BGR8;
	out_msg.image = input;
	image_pub.publish(out_msg.toImageMsg());
	return;
}

void dynamicReconfigureCallback(sharpening_filter::SharpeningFilterConfig &config, uint32_t level) {

	ros::NodeHandle nh("~");
	
	Ksize = config.Ksize;
	sigmaX = config.sigmaX;
	sigmaY = config.sigmaY;
	
	alpha = config.alpha;
	beta = config.beta;
	gammaa = config.gamma;
	
	if (!config.input_topic.empty() && !(input_topic == config.input_topic))
        {
			input_topic = config.input_topic;
			image_sub.shutdown();
			image_sub = nh.subscribe(input_topic, 1, imageCallBack);
		}
		
	if (!config.output_topic.empty() && !(output_topic == config.output_topic))
        {
			output_topic = config.output_topic;
			image_pub.shutdown();
			image_pub = nh.advertise<cv_bridge::CvImage>(output_topic, 1);
		}
	
	return;
}

int main(int argc, char** argv) {

	ros::init(argc, argv, "agent_sharpening_filter_node");
	cv_bridge::CvImagePtr inputImg;
	cv::Mat outputImg;
	
	dynamic_reconfigure::Server<sharpening_filter::SharpeningFilterConfig> server;
	dynamic_reconfigure::Server<sharpening_filter::SharpeningFilterConfig>::CallbackType f;
	f = boost::bind(&dynamicReconfigureCallback, _1, _2);
	server.setCallback(f);
	
	ros::spin();
	return 0;

}
